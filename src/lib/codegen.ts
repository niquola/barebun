import type { Context } from "../system.ts";
import { mkdir } from "node:fs/promises";
import path from "node:path";

const REPO_DIR = path.resolve(import.meta.dir, "../repo");
const TEST_DIR = path.resolve(import.meta.dir, "../../test/repo");

interface ColumnMeta {
  name: string;
  pgType: string;
  tsType: string;
  nullable: boolean;
  hasDefault: boolean;
  isArray: boolean;
  comment: string | null;
}

interface TableMeta {
  schema: string;
  table: string;
  typeName: string;
  columns: ColumnMeta[];
  pk: string[];
}

function pgTypeToTs(pgType: string, udtName?: string): string {
  if (pgType === "ARRAY" && udtName) {
    const elemType = udtElementToTs(udtName);
    return `${elemType}[]`;
  }
  switch (pgType) {
    case "integer":
    case "smallint":
    case "real":
    case "double precision":
      return "number";
    case "bigint":
      return "string";
    case "numeric":
    case "money":
      return "string";
    case "boolean":
      return "boolean";
    case "text":
    case "character varying":
    case "character":
    case "uuid":
      return "string";
    case "timestamp without time zone":
    case "timestamp with time zone":
    case "date":
      return "Date";
    case "interval":
      return "string";
    case "json":
    case "jsonb":
      return "unknown";
    case "bytea":
      return "Uint8Array";
    default:
      return "unknown";
  }
}

function udtElementToTs(udtName: string): string {
  switch (udtName) {
    case "_int2":
    case "_int4":
    case "_float4":
    case "_float8":
      return "number";
    case "_int8":
      return "string";
    case "_numeric":
      return "string";
    case "_bool":
      return "boolean";
    case "_text":
    case "_varchar":
    case "_bpchar":
    case "_uuid":
      return "string";
    case "_timestamp":
    case "_timestamptz":
    case "_date":
      return "Date";
    case "_interval":
      return "string";
    case "_json":
    case "_jsonb":
      return "unknown";
    case "_bytea":
      return "Uint8Array";
    default:
      return "unknown";
  }
}

function toPascalCase(name: string): string {
  return name
    .split(/[_-]/)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join("");
}

async function getTableMeta(
  ctx: Context,
  schema: string,
  table: string,
): Promise<TableMeta> {
  const columns = await ctx.sql`
    SELECT
      c.column_name as name,
      c.data_type as type,
      c.udt_name as udt_name,
      c.is_nullable as nullable,
      c.column_default as default_value,
      col_description(cls.oid, c.ordinal_position) as comment
    FROM information_schema.columns c
    JOIN pg_class cls ON cls.relname = c.table_name
    JOIN pg_namespace ns ON ns.oid = cls.relnamespace AND ns.nspname = c.table_schema
    WHERE c.table_schema = ${schema} AND c.table_name = ${table}
    ORDER BY c.ordinal_position
  `;

  const pkRows = await ctx.sql`
    SELECT kcu.column_name as name
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
      ON tc.constraint_name = kcu.constraint_name
      AND tc.table_schema = kcu.table_schema
    WHERE tc.constraint_type = 'PRIMARY KEY'
      AND tc.table_schema = ${schema}
      AND tc.table_name = ${table}
    ORDER BY kcu.ordinal_position
  `;

  return {
    schema,
    table,
    typeName: toPascalCase(table),
    columns: columns.map((c: any) => {
      const isJsonb = c.type === "json" || c.type === "jsonb";
      return {
        name: c.name,
        pgType: c.type,
        tsType: isJsonb && c.comment ? c.comment : pgTypeToTs(c.type, c.udt_name),
        nullable: c.nullable === "YES",
        hasDefault: c.default_value !== null,
        isArray: c.type === "ARRAY",
        comment: c.comment,
      };
    }),
    pk: pkRows.map((r: any) => r.name),
  };
}

async function listUserTables(
  ctx: Context,
  schema: string,
): Promise<string[]> {
  const rows = await ctx.sql`
    SELECT table_name as name
    FROM information_schema.tables
    WHERE table_schema = ${schema}
      AND table_type = 'BASE TABLE'
      AND left(table_name, 1) != '_'
      AND table_name NOT IN ('spatial_ref_sys')
    ORDER BY table_name
  `;
  return rows.map((r: any) => r.name);
}

function generateRepo(meta: TableMeta): string {
  const { schema, table, typeName, columns, pk } = meta;
  const fqn = `${schema}.${table}`;
  const hasPk = pk.length === 1;
  const pkCol = hasPk ? columns.find((c) => c.name === pk[0])! : null;

  const defaultCols = columns.filter((c) => c.hasDefault).map((c) => c.name);
  const arrayCols = columns.filter((c) => c.isArray).map((c) => c.name);
  const pkNames = pk;

  const lines: string[] = [];

  lines.push("// Auto-generated by codegen — DO NOT EDIT. Run: bun run db:codegen");
  lines.push('import type { Context } from "../system.ts";');
  if (arrayCols.length > 0) {
    lines.push('import { prepareForSql } from "../lib/db.ts";');
  }
  lines.push("");

  // Row type
  lines.push(`export type ${typeName} = {`);
  for (const c of columns) {
    const opt = c.nullable ? "?" : "";
    lines.push(`  ${c.name}${opt}: ${c.tsType};`);
  }
  lines.push("};");
  lines.push("");

  // Derived types
  if (defaultCols.length > 0) {
    const defaults = defaultCols.map((n) => `"${n}"`).join(" | ");
    lines.push(`type Defaults = ${defaults};`);
    lines.push(
      `export type ${typeName}Create = Omit<${typeName}, Defaults> & Partial<Pick<${typeName}, Defaults>>;`,
    );
  } else {
    lines.push(`export type ${typeName}Create = ${typeName};`);
  }
  if (pkNames.length > 0) {
    const pks = pkNames.map((n) => `"${n}"`).join(" | ");
    lines.push(
      `export type ${typeName}Update = Partial<Omit<${typeName}, ${pks}>>;`,
    );
  } else {
    lines.push(`export type ${typeName}Update = Partial<${typeName}>;`);
  }
  lines.push("");

  // Array columns set (if any)
  if (arrayCols.length > 0) {
    lines.push(
      `const ARRAY_COLS = new Set([${arrayCols.map((n) => `"${n}"`).join(", ")}]);`,
    );
    lines.push("");
  }

  // create
  lines.push(
    `export async function create(ctx: Context, data: ${typeName}Create): Promise<${typeName}> {`,
  );
  if (arrayCols.length > 0) {
    lines.push(
      "  const [row] = await ctx.sql`INSERT INTO " +
        fqn +
        " ${ctx.sql(prepareForSql(data as any, ARRAY_COLS))} RETURNING *`;",
    );
  } else {
    lines.push(
      "  const [row] = await ctx.sql`INSERT INTO " +
        fqn +
        " ${ctx.sql(data)} RETURNING *`;",
    );
  }
  lines.push(`  return row as ${typeName};`);
  lines.push("}");
  lines.push("");

  if (hasPk && pkCol) {
    const pkName = pkCol.name;
    const pkType = pkCol.tsType;

    // read
    lines.push(
      `export async function read(ctx: Context, ${pkName}: ${pkType}): Promise<${typeName} | null> {`,
    );
    lines.push(
      "  const rows = await ctx.sql`SELECT * FROM " +
        fqn +
        " WHERE " +
        pkName +
        " = ${" +
        pkName +
        "}`;",
    );
    lines.push(`  return (rows[0] as ${typeName}) ?? null;`);
    lines.push("}");
    lines.push("");

    // update
    lines.push(
      `export async function update(ctx: Context, ${pkName}: ${pkType}, data: ${typeName}Update): Promise<${typeName} | null> {`,
    );
    if (arrayCols.length > 0) {
      lines.push(
        "  const rows = await ctx.sql`UPDATE " +
          fqn +
          " SET ${ctx.sql(prepareForSql(data as any, ARRAY_COLS))} WHERE " +
          pkName +
          " = ${" +
          pkName +
          "} RETURNING *`;",
      );
    } else {
      lines.push(
        "  const rows = await ctx.sql`UPDATE " +
          fqn +
          " SET ${ctx.sql(data)} WHERE " +
          pkName +
          " = ${" +
          pkName +
          "} RETURNING *`;",
      );
    }
    lines.push(`  return (rows[0] as ${typeName}) ?? null;`);
    lines.push("}");
    lines.push("");

    // remove
    lines.push(
      `export async function remove(ctx: Context, ${pkName}: ${pkType}): Promise<boolean> {`,
    );
    lines.push(
      "  const rows = await ctx.sql`DELETE FROM " +
        fqn +
        " WHERE " +
        pkName +
        " = ${" +
        pkName +
        "} RETURNING " +
        pkName +
        "`;",
    );
    lines.push("  return rows.length > 0;");
    lines.push("}");
    lines.push("");

    // list
    lines.push(
      `export async function list(ctx: Context, opts: { limit?: number; offset?: number } = {}): Promise<${typeName}[]> {`,
    );
    lines.push("  const { limit = 100, offset = 0 } = opts;");
    lines.push(
      "  return await ctx.sql`SELECT * FROM " +
        fqn +
        " ORDER BY " +
        pkName +
        " LIMIT ${limit} OFFSET ${offset}` as " +
        typeName +
        "[];",
    );
    lines.push("}");
  } else {
    // list only (no PK)
    lines.push(
      `export async function list(ctx: Context, opts: { limit?: number; offset?: number } = {}): Promise<${typeName}[]> {`,
    );
    lines.push("  const { limit = 100, offset = 0 } = opts;");
    lines.push(
      "  return await ctx.sql`SELECT * FROM " +
        fqn +
        " LIMIT ${limit} OFFSET ${offset}` as " +
        typeName +
        "[];",
    );
    lines.push("}");
  }

  lines.push("");
  return lines.join("\n");
}

function generateWrapper(meta: TableMeta): string {
  const { table, typeName, pk, columns } = meta;
  const hasPk = pk.length === 1;
  const pkCol = hasPk ? columns.find((c) => c.name === pk[0])! : null;

  const lines: string[] = [];
  lines.push(`// Custom repo for ${table} — add validation, hooks, custom queries here.`);
  lines.push('import type { Context } from "../system.ts";');
  lines.push(
    `import { type ${typeName}, type ${typeName}Create, type ${typeName}Update,`,
  );
  lines.push(
    `  create as _create, ${hasPk ? "read as _read, update as _update, remove as _remove, " : ""}list as _list`,
  );
  lines.push(`} from "./${table}.gen.ts";`);
  lines.push("");
  lines.push(`export type { ${typeName}, ${typeName}Create, ${typeName}Update };`);
  lines.push("");

  // create
  lines.push(
    `export async function create(ctx: Context, data: ${typeName}Create): Promise<${typeName}> {`,
  );
  lines.push("  // TODO: add validation");
  lines.push("  return _create(ctx, data);");
  lines.push("}");
  lines.push("");

  if (hasPk && pkCol) {
    const pkName = pkCol.name;
    const pkType = pkCol.tsType;

    // read
    lines.push(
      `export async function read(ctx: Context, ${pkName}: ${pkType}): Promise<${typeName} | null> {`,
    );
    lines.push(`  return _read(ctx, ${pkName});`);
    lines.push("}");
    lines.push("");

    // update
    lines.push(
      `export async function update(ctx: Context, ${pkName}: ${pkType}, data: ${typeName}Update): Promise<${typeName} | null> {`,
    );
    lines.push("  // TODO: add validation");
    lines.push(`  return _update(ctx, ${pkName}, data);`);
    lines.push("}");
    lines.push("");

    // remove
    lines.push(
      `export async function remove(ctx: Context, ${pkName}: ${pkType}): Promise<boolean> {`,
    );
    lines.push(`  return _remove(ctx, ${pkName});`);
    lines.push("}");
    lines.push("");
  }

  // list
  lines.push(
    `export async function list(ctx: Context, opts: { limit?: number; offset?: number } = {}): Promise<${typeName}[]> {`,
  );
  lines.push("  return _list(ctx, opts);");
  lines.push("}");
  lines.push("");

  // Example custom search
  const searchCol = columns.find(
    (c) => c.name !== pk[0] && c.pgType === "text" && !c.nullable,
  );
  if (searchCol) {
    lines.push(`// Example: custom search by ${searchCol.name}`);
    lines.push(
      `export async function searchBy${toPascalCase(searchCol.name)}(ctx: Context, q: string): Promise<${typeName}[]> {`,
    );
    lines.push(
      `  return await ctx.sql\`SELECT * FROM ${meta.schema}.${table} WHERE ${searchCol.name} ILIKE \${"%" + q + "%"} LIMIT 100\` as ${typeName}[];`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

function sampleValue(c: ColumnMeta, index: number): string {
  if (c.comment) return "undefined"; // JSONB with typed comment — skip
  switch (c.tsType) {
    case "string":
      return `"${c.name}_${index}"`;
    case "number":
      return `${index}`;
    case "boolean":
      return "true";
    case "Date":
      return "new Date()";
    default:
      return "undefined";
  }
}

function generateTest(meta: TableMeta): string {
  const { table, typeName, pk, columns } = meta;
  const hasPk = pk.length === 1;
  const pkCol = hasPk ? columns.find((c) => c.name === pk[0])! : null;

  // Required columns for create: non-nullable, no default, not PK
  const requiredCols = columns.filter(
    (c) => !c.nullable && !c.hasDefault && !pk.includes(c.name),
  );

  function sampleObj(index: number): string {
    const fields = requiredCols
      .map((c) => {
        const val = sampleValue(c, index);
        return val !== "undefined" ? `${c.name}: ${val}` : null;
      })
      .filter(Boolean);
    return `{ ${fields.join(", ")} }`;
  }

  const lines: string[] = [];
  lines.push('import { describe, it, expect, beforeAll, afterAll } from "bun:test";');
  lines.push('import { startTest, stop, withTx, type Context } from "@/system.ts";');
  lines.push(`import * as repo from "@/repo/${table}.ts";`);
  lines.push("");
  lines.push("let ctx: Context;");
  lines.push("");
  lines.push("beforeAll(async () => {");
  lines.push("  ctx = await startTest();");
  lines.push("});");
  lines.push("");
  lines.push("afterAll(async () => {");
  lines.push("  await stop(ctx);");
  lines.push("});");
  lines.push("");
  lines.push(`describe("${table} repo", () => {`);

  if (hasPk && pkCol) {
    const pkName = pkCol.name;

    // create + read
    lines.push("  it(");
    lines.push('    "create + read",');
    lines.push("    withTx(() => ctx, async (tx) => {");
    lines.push(`      const row = await repo.create(tx, ${sampleObj(1)});`);
    lines.push(`      expect(row.${pkName}).toBeDefined();`);
    lines.push("");
    lines.push(`      const found = await repo.read(tx, row.${pkName});`);
    lines.push("      expect(found).not.toBeNull();");
    for (const c of requiredCols) {
      const val = sampleValue(c, 1);
      if (val !== "undefined") {
        lines.push(`      expect(found!.${c.name}).toBe(${val});`);
      }
    }
    lines.push("    }),");
    lines.push("  );");
    lines.push("");

    // update
    const updatableCol = requiredCols.find(
      (c) => c.tsType === "string" && !pk.includes(c.name),
    );
    if (updatableCol) {
      lines.push("  it(");
      lines.push('    "update",');
      lines.push("    withTx(() => ctx, async (tx) => {");
      lines.push(`      const row = await repo.create(tx, ${sampleObj(2)});`);
      lines.push(
        `      const updated = await repo.update(tx, row.${pkName}, { ${updatableCol.name}: "${updatableCol.name}_updated" });`,
      );
      lines.push("      expect(updated).not.toBeNull();");
      lines.push(
        `      expect(updated!.${updatableCol.name}).toBe("${updatableCol.name}_updated");`,
      );
      lines.push("    }),");
      lines.push("  );");
      lines.push("");
    }

    // remove
    lines.push("  it(");
    lines.push('    "remove",');
    lines.push("    withTx(() => ctx, async (tx) => {");
    lines.push(`      const row = await repo.create(tx, ${sampleObj(3)});`);
    lines.push(`      const ok = await repo.remove(tx, row.${pkName});`);
    lines.push("      expect(ok).toBe(true);");
    lines.push("");
    lines.push(`      const gone = await repo.read(tx, row.${pkName});`);
    lines.push("      expect(gone).toBeNull();");
    lines.push("    }),");
    lines.push("  );");
    lines.push("");
  }

  // list
  lines.push("  it(");
  lines.push('    "list",');
  lines.push("    withTx(() => ctx, async (tx) => {");
  lines.push(`      await repo.create(tx, ${sampleObj(10)});`);
  lines.push(`      await repo.create(tx, ${sampleObj(11)});`);
  lines.push(`      await repo.create(tx, ${sampleObj(12)});`);
  lines.push("");
  lines.push("      const all = await repo.list(tx);");
  lines.push("      expect(all.length).toBe(3);");
  lines.push("    }),");
  lines.push("  );");

  lines.push("});");
  lines.push("");
  return lines.join("\n");
}

export async function generate(
  ctx: Context,
  opts: { schema?: string; tables?: string[] } = {},
) {
  const schema = opts.schema ?? "public";
  const tableNames = opts.tables?.length
    ? opts.tables
    : await listUserTables(ctx, schema);

  if (tableNames.length === 0) {
    console.log("No tables found.");
    return;
  }

  await mkdir(REPO_DIR, { recursive: true });
  await mkdir(TEST_DIR, { recursive: true });

  for (const name of tableNames) {
    const meta = await getTableMeta(ctx, schema, name);

    // .gen.ts — always overwritten
    const genFile = path.join(REPO_DIR, `${name}.gen.ts`);
    await Bun.write(genFile, generateRepo(meta));

    // .ts — created only if missing
    const wrapperFile = path.join(REPO_DIR, `${name}.ts`);
    const wrapperExists = await Bun.file(wrapperFile).exists();
    if (!wrapperExists) {
      await Bun.write(wrapperFile, generateWrapper(meta));
      console.log(
        `  src/repo/${name}.ts       (new wrapper)`,
      );
    }

    // test — created only if missing
    const testFile = path.join(TEST_DIR, `${name}.test.ts`);
    const testExists = await Bun.file(testFile).exists();
    if (!testExists) {
      await Bun.write(testFile, generateTest(meta));
      console.log(
        `  test/repo/${name}.test.ts (new test)`,
      );
    }

    console.log(
      `  src/repo/${name}.gen.ts   (${meta.columns.length} cols, pk: ${meta.pk.join(", ") || "none"})`,
    );
  }

  console.log(`\n${tableNames.length} repo(s) generated.`);
}
